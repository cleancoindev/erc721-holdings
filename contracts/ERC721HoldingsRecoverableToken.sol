pragma solidity ^0.4.23;

import "./ERC721HoldingsMintable.sol";
import "./ERC721HoldingsBasicToken.sol";

/**
 * @title Holdings of ERC-721 Non-Fungible Token Standard, optional recoverable token implementation
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */
contract ERC721HoldingsRecoverableToken is ERC721HoldingsMintable, ERC721HoldingsBasicToken {

  /**
   * @dev Gets the isRecoverable flag for the requested token
   * @dev Autogenerated getter for the mapping that holds a bool flag for every token representing
   *  if the token is recoverable by owner
   * @param _tokenId uint256 ID of the token
   * @return bool flag for the requested token representing if the requested token is recoverable
   *  by the Kittyland token owner
   */
  mapping (uint256 => bool) public isRecoverable;

  /**
   * @dev Internal function to mint a new token
   * @dev Reverts if the given token ID already exists
   * @param _to The holder ID that will hold the minted token
   * @param _toOrigin address of the holder's origin
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender
   */
  function mint(uint256 _to, address _toOrigin, uint256 _tokenId) public {
    mint(_to, _toOrigin, _tokenId, false);
  }

  /**
   * @dev Function to mint a new token
   * @dev Reverts if the given token ID already exists
   * @param _to The holder ID that will hold the minted token
   * @param _toOrigin address of the holder's origin
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender
   * @param _recoverable bool value representing if the holding is recoverable by the token owner
   */
  function mint(uint256 _to, address _toOrigin, uint256 _tokenId, bool _recoverable) public onlyTokenOwnerOf(_tokenId) {
    _mint(_to, _toOrigin, _tokenId);
    isRecoverable[_tokenId] = _recoverable;
  }

 /**
   * @dev Function to burn a specific token
   * @dev Reverts if the token does not exist
   * @param _owner The address of token owner
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function burn(address _owner, uint256 _tokenId) public {
    require(_isBurnable(_tokenId) || _isRecoverable(_tokenId));
    _burn(_owner, _tokenId);
    delete isRecoverable[_tokenId];
  }

  /**
   * @dev Internal function to recover a specific token
   * @dev Token is burned by the token owner and minted to a new holder
   * @dev Reverts if the token does not exist
   * @param _to The holder ID that will hold the minted token
   * @param _toOrigin address of the holder's origin
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function recover(uint256 _to, address _toOrigin, uint256 _tokenId) public {
    recover(ownerOf(_tokenId), _to, _toOrigin, _tokenId);
  }

  /**
   * @dev Internal function to burn a specific token
   * @dev Token is burned by the token owner and minted to a new holder
   * @dev Reverts if the token does not exist
   * @param _owner The address of token owner
   * @param _to The holder ID that will hold the minted token
   * @param _toOrigin address of the holder's origin
   * @param _tokenId uint256 ID of the token being burned by the msg.sender
   */
  function recover(address _owner, uint256 _to, address _toOrigin, uint256 _tokenId) public {
    require(_isRecoverable(_tokenId));
    _burn(_owner, _tokenId);
    _mint(_to, _toOrigin, _tokenId);
  }

  /**
   * @dev Checks if token is declared burnable and msg.sender is Kittyland token owner.
   * @param _tokenId uint256 ID of the token
   * @return bool whether the _tokenId is burnable or not
   */
  function _isRecoverable(uint256 _tokenId) internal view returns (bool) {
    return isRecoverable[_tokenId] && tokenOwnerOf(_tokenId) == msg.sender;
  }

  /**
   * @dev Checks if token is allowed to be burned burnable by msg.sender
   * @param _tokenId uint256 ID of the token
   * @return bool whether the _tokenId is burnable or not
   */
  function _isBurnable(uint256 _tokenId) internal view returns (bool) {
    return ownerOf(_tokenId) == msg.sender;
  }

}
